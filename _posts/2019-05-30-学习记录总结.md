---
layout:     post   				    # 使用的布局（不需要改）
title:      2019-05-30-学习记录总结			# 标题 
subtitle:   第二章 #副标题
date:       2019-05-30				# 时间
author:     GSJ 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 学习
---

# Hey
>总结：信息存储
字节是内存的最小可寻址单位，内存被视为一个非常大的字节数组，称为虚拟内存，内存的每一个字节由唯一的一个数字标识，称为地址，所有可能的地址的集合称为虚拟地址空间。
十六进制标识法。
一个字节由八位组成，这里的位都是指二进制位，人们发现用‘0’，‘1’串标识数据太过冗长，通常用十六进制标识计算机中的位模式。十六进制和二进制之间的转换非常简单，每四位二进制位对应一个十六进制数，不足四位的高位补零。约定以0x开头的数字为十六进制的值。
寻址和字节顺序。
    小端法。 最低有效字节在最前面。
    大端法。 最高有效字节在最前面。
大多数Intel兼容机器只用小端模式，IBM和Oracle的大多数机器采用大多数模式。许多新的微处理器采用双端法，移动端的Android和IOS只能运行于小端模式。
C语言中的移位操作
    左移。低位补零。
    算数右移。高位补之前的最高位的值。
    逻辑右移。高位补零。
回到顶部
整数表示
无符号数编码
对于w位的二进制向量（Xw-1，Xw-2，······，X0），其每一位的权重为2^w-1,因此这个向量的十进制值为Xw-12^w-1+Xw-22^w-2+···+X0*1。
补码编码
相较于无符号编码，除最高位权重为负，别的一样。
无符号数编码和补码编码都具有唯一性
有符号数和无符号数转换
只需要记住一个原则，转换中位模式不变。
扩展一个数字的位表示
    无符号数零扩展。在高位之前添加零。
    补码数的符号扩展。在高位添加符号位的值。
小类型向大类型转变，先改变大小（扩展），再转换类型。
回到顶部
整数运算
无符号加法、补码加法
可以理解为处理好溢出之后，再转换为相应的位模式。当然机器内的运算是位运算。
补码的非
注意TMin的非就是TMin。
无符号乘法和补码的乘法
其实和加法一样，先处理算数数值，再转换成二进制位模式。
乘以常数
很容易理解乘以2的幂等同于移位操作，于是将整数改写成多个2的幂相加的形式或两个二的幂相减的形式可以较快速的计算乘以常数的结果。
除以2的幂
移位操作，注意无符号数逻辑移位，有符号数算数移位。
小结
补码与无符号算术采用相同的位级操作，这些运算包括加法、减法、乘法、除法，无论运算数是以无符号形式还是以补码形式表示的，都有完全一样或非常相似的位级行为。
回到顶部
浮点数
浮点数将32位或64位分成三部分，第一位用作符号位，第二部分用于存储指数（2的多少次幂），第三部分存储尾数（小数点后的数，通常小数点前是一，非规格化的时候是0）。
浮点数的舍入
分四种舍入方式，分别为向偶数舍入（减小统计误差），向零舍入，向上舍入和向下舍入。
浮点数运算
很奇怪为什么这本书里这部分写的为什么很简略，简单分为五个步骤：
对阶-尾数求和-规格化-舍入-溢出判断。具体可以参考浮点数的表示和运算
重要
float sun_elements(float a[], unsigned length){
    int i;
    float result = O;
    for (i = O; i <= length - 1; i++)
        result += a[i];
    return result;
}

因为length使用的unsigned类型，因此length-1使用无符号运算，因此length为零时将得到UMax，出错。改正可以：

    unsigned类型改用int。
    在进入函数时检查length
    判断条件改用i<length。实际上这也是平时编程时提倡采用的方式，每一次循环都能减少一次运算。

实际上我也不知道为什么要把这个写到问题里，但是既然当时标注了，还是写进来，提醒自己养成良好的变成习惯（i<length）。
